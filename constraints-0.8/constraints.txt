-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Constraint manipulation
--   
--   GHC 7.4 gave us the ability to talk about <tt>ConstraintKinds</tt>.
--   They stopped crashing the compiler in GHC 7.6.
--   
--   This package provides a vocabulary for working with them.
@package constraints
@version 0.8


-- | <tt>ConstraintKinds</tt> made type classes into types of a new kind,
--   <tt>Constraint</tt>.
--   
--   <pre>
--   <a>Eq</a> :: * -&gt; <a>Constraint</a>
--   <a>Ord</a> :: * -&gt; <a>Constraint</a>
--   <a>Monad</a> :: (* -&gt; *) -&gt; <a>Constraint</a>
--   </pre>
--   
--   The need for this extension was first publicized in the paper
--   
--   <a>Scrap your boilerplate with class: extensible generic functions</a>
--   
--   by Ralf LÃ¤mmel and Simon Peyton Jones in 2005, which shoehorned all
--   the things they needed into a custom <tt>Sat</tt> typeclass.
--   
--   With <tt>ConstraintKinds</tt> we can put into code a lot of tools for
--   manipulating these new types without such awkward workarounds.
module Data.Constraint
data Constraint :: BOX

-- | Values of type <tt><a>Dict</a> p</tt> capture a dictionary for a
--   constraint of type <tt>p</tt>.
--   
--   e.g.
--   
--   <pre>
--   <a>Dict</a> :: <a>Dict</a> (<a>Eq</a> <a>Int</a>)
--   </pre>
--   
--   captures a dictionary that proves we have an:
--   
--   <pre>
--   instance <a>Eq</a> 'Int
--   </pre>
--   
--   Pattern matching on the <a>Dict</a> constructor will bring this
--   instance into scope.
data Dict :: Constraint -> *
Dict :: Dict a

-- | This is the type of entailment.
--   
--   <tt>a <a>:-</a> b</tt> is read as <tt>a</tt> "entails" <tt>b</tt>.
--   
--   With this we can actually build a category for <a>Constraint</a>
--   resolution.
--   
--   e.g.
--   
--   Because <tt><a>Eq</a> a</tt> is a superclass of <tt><a>Ord</a> a</tt>,
--   we can show that <tt><a>Ord</a> a</tt> entails <tt><a>Eq</a> a</tt>.
--   
--   Because <tt>instance <a>Ord</a> a =&gt; <a>Ord</a> [a]</tt> exists, we
--   can show that <tt><a>Ord</a> a</tt> entails <tt><a>Ord</a> [a]</tt> as
--   well.
--   
--   This relationship is captured in the <a>:-</a> entailment type here.
--   
--   Since <tt>p <a>:-</a> p</tt> and entailment composes, <a>:-</a> forms
--   the arrows of a <a>Category</a> of constraints. However,
--   <a>Category</a> only because sufficiently general to support this
--   instance in GHC 7.8, so prior to 7.8 this instance is unavailable.
--   
--   But due to the coherence of instance resolution in Haskell, this
--   <a>Category</a> has some very interesting properties. Notably, in the
--   absence of <tt>IncoherentInstances</tt>, this category is "thin",
--   which is to say that between any two objects (constraints) there is at
--   most one distinguishable arrow.
--   
--   This means that for instance, even though there are two ways to derive
--   <tt><a>Ord</a> a <a>:-</a> <a>Eq</a> [a]</tt>, the answers from these
--   two paths _must_ by construction be equal. This is a property that
--   Haskell offers that is pretty much unique in the space of languages
--   with things they call "type classes".
--   
--   What are the two ways?
--   
--   Well, we can go from <tt><a>Ord</a> a <a>:-</a> <a>Eq</a> a</tt> via
--   the superclass relationship, and them from <tt><a>Eq</a> a <a>:-</a>
--   <a>Eq</a> [a]</tt> via the instance, or we can go from <tt><a>Ord</a>
--   a <a>:-</a> <a>Ord</a> [a]</tt> via the instance then from
--   <tt><a>Ord</a> [a] <a>:-</a> <a>Eq</a> [a]</tt> through the superclass
--   relationship and this diagram by definition must "commute".
--   
--   Diagrammatically,
--   
--   <pre>
--          Ord a
--      ins /     \ cls
--         v       v
--   Ord [a]     Eq a
--      cls \     / ins
--           v   v
--          Eq [a]
--   </pre>
--   
--   This safety net ensures that pretty much anything you can write with
--   this library is sensible and can't break any assumptions on the behalf
--   of library authors.
newtype (:-) a b
Sub :: (a => Dict b) -> (:-) a b

-- | Given that <tt>a :- b</tt>, derive something that needs a context
--   <tt>b</tt>, using the context <tt>a</tt>
(\\) :: a => (b => r) -> (a :- b) -> r

-- | Weakening a constraint product
--   
--   The category of constraints is Cartesian. We can forget information.
weaken1 :: (a, b) :- a

-- | Weakening a constraint product
--   
--   The category of constraints is Cartesian. We can forget information.
weaken2 :: (a, b) :- b

-- | Contracting a constraint / diagonal morphism
--   
--   The category of constraints is Cartesian. We can reuse information.
contract :: a :- (a, a)

-- | Constraint product
--   
--   <pre>
--   trans weaken1 (f &amp;&amp;&amp; g) = f
--   trans weaken2 (f &amp;&amp;&amp; g) = g
--   </pre>
(&&&) :: (a :- b) -> (a :- c) -> a :- (b, c)

-- | due to the hack for the kind of <tt>(,)</tt> in the current version of
--   GHC we can't actually make instances for <tt>(,) :: Constraint -&gt;
--   Constraint -&gt; Constraint</tt>, but <tt>(,)</tt> is a bifunctor on
--   the category of constraints. This lets us map over both sides.
(***) :: (a :- b) -> (c :- d) -> (a, c) :- (b, d)

-- | Transitivity of entailment
--   
--   If we view <tt>(<a>:-</a>)</tt> as a Constraint-indexed category, then
--   this is <tt>(<a>.</a>)</tt>
trans :: (b :- c) -> (a :- b) -> a :- c

-- | Reflexivity of entailment
--   
--   If we view <tt>(<a>:-</a>)</tt> as a Constraint-indexed category, then
--   this is <a>id</a>
refl :: a :- a

-- | <tt>Any</tt> inhabits every kind, including <a>Constraint</a> but is
--   uninhabited, making it impossible to define an instance.
class Any => Bottom

-- | Every constraint implies truth
--   
--   These are the terminal arrows of the category, and <tt>()</tt> is the
--   terminal object.
--   
--   Given any constraint there is a unique entailment of the <tt>()</tt>
--   constraint from that constraint.
top :: a :- ()

-- | This demonstrates the law of classical logic <a>"ex falso
--   quodlibet"</a>
bottom :: Bottom :- a

-- | Apply an entailment to a dictionary.
--   
--   From a category theoretic perspective <a>Dict</a> is a functor that
--   maps from the category of constraints (with arrows in <a>:-</a>) to
--   the category Hask of Haskell data types.
mapDict :: (a :- b) -> Dict a -> Dict b

-- | This functor is fully faithful, which is to say that given any
--   function you can write <tt>Dict a -&gt; Dict b</tt> there also exists
--   an entailment <tt>a :- b</tt> in the category of constraints that you
--   can build.
unmapDict :: (Dict a -> Dict b) -> a :- b

-- | Reify the relationship between a class and its superclass constraints
--   as a class
--   
--   Given a definition such as
--   
--   <pre>
--   class Foo a =&gt; Bar a
--   </pre>
--   
--   you can capture the relationship between 'Bar a' and its superclass
--   'Foo a' with
--   
--   <pre>
--   instance <a>Class</a> (Foo a) (Bar a) where <a>cls</a> = <a>Sub</a> <a>Dict</a>
--   </pre>
--   
--   Now the user can use 'cls :: Bar a :- Foo a'
class Class b h | h -> b
cls :: Class b h => h :- b

-- | Reify the relationship between an instance head and its body as a
--   class
--   
--   Given a definition such as
--   
--   <pre>
--   instance Foo a =&gt; Foo [a]
--   </pre>
--   
--   you can capture the relationship between the instance head and its
--   body with
--   
--   <pre>
--   instance Foo a <a>:=&gt;</a> Foo [a] where <a>ins</a> = <a>Sub</a> <a>Dict</a>
--   </pre>
class (:=>) b h | h -> b
ins :: (:=>) b h => b :- h
instance GHC.Classes.Eq (Data.Constraint.Dict a)
instance GHC.Classes.Ord (Data.Constraint.Dict a)
instance GHC.Show.Show (Data.Constraint.Dict a)
instance a => GHC.Read.Read (Data.Constraint.Dict a)
instance (Data.Typeable.Internal.Typeable p, p) => Data.Data.Data (Data.Constraint.Dict p)
instance (Data.Typeable.Internal.Typeable p, Data.Typeable.Internal.Typeable q, p, q) => Data.Data.Data (p Data.Constraint.:- q)
instance Control.Category.Category (Data.Constraint.:-)
instance GHC.Classes.Eq (a Data.Constraint.:- b)
instance GHC.Classes.Ord (a Data.Constraint.:- b)
instance GHC.Show.Show (a Data.Constraint.:- b)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (Data.Constraint.Class b a)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (b Data.Constraint.:=> a)
instance Data.Constraint.Class b a => (() :: GHC.Prim.Constraint) Data.Constraint.:=> Data.Constraint.Class b a
instance (b Data.Constraint.:=> a) => (() :: GHC.Prim.Constraint) Data.Constraint.:=> (b Data.Constraint.:=> a)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (() :: GHC.Prim.Constraint)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> (() :: GHC.Prim.Constraint)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (GHC.Classes.Eq a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Eq ()
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Types.Int
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Types.Bool
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Integer.Type.Integer
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Types.Float
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Eq GHC.Types.Double
instance GHC.Classes.Eq a Data.Constraint.:=> GHC.Classes.Eq [a]
instance GHC.Classes.Eq a Data.Constraint.:=> GHC.Classes.Eq (GHC.Base.Maybe a)
instance GHC.Classes.Eq a Data.Constraint.:=> GHC.Classes.Eq (Data.Complex.Complex a)
instance GHC.Classes.Eq a Data.Constraint.:=> GHC.Classes.Eq (GHC.Real.Ratio a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) Data.Constraint.:=> GHC.Classes.Eq (a, b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) Data.Constraint.:=> GHC.Classes.Eq (Data.Either.Either a b)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Eq (Data.Constraint.Dict a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Eq (a Data.Constraint.:- b)
instance Data.Constraint.Class (GHC.Classes.Eq a) (GHC.Classes.Ord a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Ord ()
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Bool
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Int
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Integer.Type.Integer
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Float
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Double
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Ord GHC.Types.Char
instance GHC.Classes.Ord a Data.Constraint.:=> GHC.Classes.Ord (GHC.Base.Maybe a)
instance GHC.Classes.Ord a Data.Constraint.:=> GHC.Classes.Ord [a]
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) Data.Constraint.:=> GHC.Classes.Ord (a, b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) Data.Constraint.:=> GHC.Classes.Ord (Data.Either.Either a b)
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Classes.Ord (GHC.Real.Ratio a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Ord (Data.Constraint.Dict a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Classes.Ord (a Data.Constraint.:- b)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (GHC.Show.Show a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Show.Show ()
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Show.Show GHC.Types.Bool
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Show.Show GHC.Types.Ordering
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Show.Show GHC.Types.Char
instance GHC.Show.Show a Data.Constraint.:=> GHC.Show.Show (Data.Complex.Complex a)
instance GHC.Show.Show a Data.Constraint.:=> GHC.Show.Show [a]
instance GHC.Show.Show a Data.Constraint.:=> GHC.Show.Show (GHC.Base.Maybe a)
instance (GHC.Show.Show a, GHC.Show.Show b) Data.Constraint.:=> GHC.Show.Show (a, b)
instance (GHC.Show.Show a, GHC.Show.Show b) Data.Constraint.:=> GHC.Show.Show (Data.Either.Either a b)
instance (GHC.Real.Integral a, GHC.Show.Show a) Data.Constraint.:=> GHC.Show.Show (GHC.Real.Ratio a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Show.Show (Data.Constraint.Dict a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Show.Show (a Data.Constraint.:- b)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (GHC.Read.Read a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Read.Read ()
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Read.Read GHC.Types.Bool
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Read.Read GHC.Types.Ordering
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Read.Read GHC.Types.Char
instance GHC.Read.Read a Data.Constraint.:=> GHC.Read.Read (Data.Complex.Complex a)
instance GHC.Read.Read a Data.Constraint.:=> GHC.Read.Read [a]
instance GHC.Read.Read a Data.Constraint.:=> GHC.Read.Read (GHC.Base.Maybe a)
instance (GHC.Read.Read a, GHC.Read.Read b) Data.Constraint.:=> GHC.Read.Read (a, b)
instance (GHC.Read.Read a, GHC.Read.Read b) Data.Constraint.:=> GHC.Read.Read (Data.Either.Either a b)
instance (GHC.Real.Integral a, GHC.Read.Read a) Data.Constraint.:=> GHC.Read.Read (GHC.Real.Ratio a)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (GHC.Enum.Enum a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Enum ()
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Bool
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Ordering
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Char
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Int
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Integer.Type.Integer
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Float
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Enum GHC.Types.Double
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Enum.Enum (GHC.Real.Ratio a)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (GHC.Enum.Bounded a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Bounded ()
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Bounded GHC.Types.Ordering
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Bounded GHC.Types.Bool
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Bounded GHC.Types.Int
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Enum.Bounded GHC.Types.Char
instance (GHC.Enum.Bounded a, GHC.Enum.Bounded b) Data.Constraint.:=> GHC.Enum.Bounded (a, b)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (GHC.Num.Num a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Num.Num GHC.Types.Int
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Num.Num GHC.Integer.Type.Integer
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Num.Num GHC.Types.Float
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Num.Num GHC.Types.Double
instance GHC.Float.RealFloat a Data.Constraint.:=> GHC.Num.Num (Data.Complex.Complex a)
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Num.Num (GHC.Real.Ratio a)
instance Data.Constraint.Class (GHC.Num.Num a, GHC.Classes.Ord a) (GHC.Real.Real a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Real.Real GHC.Types.Int
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Real.Real GHC.Integer.Type.Integer
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Real.Real GHC.Types.Float
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Real.Real GHC.Types.Double
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Real.Real (GHC.Real.Ratio a)
instance Data.Constraint.Class (GHC.Real.Real a, GHC.Enum.Enum a) (GHC.Real.Integral a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Real.Integral GHC.Types.Int
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Real.Integral GHC.Integer.Type.Integer
instance Data.Constraint.Class (GHC.Num.Num a) (GHC.Real.Fractional a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Real.Fractional GHC.Types.Float
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Real.Fractional GHC.Types.Double
instance GHC.Float.RealFloat a Data.Constraint.:=> GHC.Real.Fractional (Data.Complex.Complex a)
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Real.Fractional (GHC.Real.Ratio a)
instance Data.Constraint.Class (GHC.Real.Fractional a) (GHC.Float.Floating a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Float.Floating GHC.Types.Float
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Float.Floating GHC.Types.Double
instance GHC.Float.RealFloat a Data.Constraint.:=> GHC.Float.Floating (Data.Complex.Complex a)
instance Data.Constraint.Class (GHC.Real.Real a, GHC.Real.Fractional a) (GHC.Real.RealFrac a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Real.RealFrac GHC.Types.Float
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Real.RealFrac GHC.Types.Double
instance GHC.Real.Integral a Data.Constraint.:=> GHC.Real.RealFrac (GHC.Real.Ratio a)
instance Data.Constraint.Class (GHC.Real.RealFrac a, GHC.Float.Floating a) (GHC.Float.RealFloat a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Float.RealFloat GHC.Types.Float
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Float.RealFloat GHC.Types.Double
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (GHC.Base.Monoid a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Monoid ()
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Monoid GHC.Types.Ordering
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Monoid [a]
instance GHC.Base.Monoid a Data.Constraint.:=> GHC.Base.Monoid (GHC.Base.Maybe a)
instance (GHC.Base.Monoid a, GHC.Base.Monoid b) Data.Constraint.:=> GHC.Base.Monoid (a, b)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (GHC.Base.Functor f)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Functor []
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Functor GHC.Base.Maybe
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Functor (Data.Either.Either a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Functor ((->) a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Functor ((,) a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Functor GHC.Types.IO
instance GHC.Base.Monad m Data.Constraint.:=> GHC.Base.Functor (Control.Applicative.WrappedMonad m)
instance Data.Constraint.Class (GHC.Base.Functor f) (GHC.Base.Applicative f)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Applicative []
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Applicative GHC.Base.Maybe
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Applicative (Data.Either.Either a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Applicative ((->) a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Applicative GHC.Types.IO
instance GHC.Base.Monoid a Data.Constraint.:=> GHC.Base.Applicative ((,) a)
instance GHC.Base.Monad m Data.Constraint.:=> GHC.Base.Applicative (Control.Applicative.WrappedMonad m)
instance Data.Constraint.Class (GHC.Base.Applicative f) (GHC.Base.Alternative f)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Alternative []
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Alternative GHC.Base.Maybe
instance GHC.Base.MonadPlus m Data.Constraint.:=> GHC.Base.Alternative (Control.Applicative.WrappedMonad m)
instance Data.Constraint.Class (() :: GHC.Prim.Constraint) (GHC.Base.Monad f)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Monad []
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Monad ((->) a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Monad (Data.Either.Either a)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.Monad GHC.Types.IO
instance Data.Constraint.Class (GHC.Base.Monad f) (GHC.Base.MonadPlus f)
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.MonadPlus []
instance (() :: GHC.Prim.Constraint) Data.Constraint.:=> GHC.Base.MonadPlus GHC.Base.Maybe
instance a Data.Constraint.:=> GHC.Enum.Enum (Data.Constraint.Dict a)
instance a => GHC.Enum.Enum (Data.Constraint.Dict a)
instance a Data.Constraint.:=> GHC.Enum.Bounded (Data.Constraint.Dict a)
instance a => GHC.Enum.Bounded (Data.Constraint.Dict a)
instance a Data.Constraint.:=> GHC.Read.Read (Data.Constraint.Dict a)
instance a Data.Constraint.:=> GHC.Base.Monoid (Data.Constraint.Dict a)
instance a => GHC.Base.Monoid (Data.Constraint.Dict a)


-- | The idea for this trick comes from Dimitrios Vytiniotis.
module Data.Constraint.Deferrable
data UnsatisfiedConstraint
UnsatisfiedConstraint :: String -> UnsatisfiedConstraint

-- | Allow an attempt at resolution of a constraint at a later time
class Deferrable (p :: Constraint)

-- | Resolve a <a>Deferrable</a> constraint with observable failure.
deferEither :: Deferrable p => proxy p -> (p => r) -> Either String r

-- | Defer a constraint for later resolution in a context where we want to
--   upgrade failure into an error
defer :: Deferrable p => proxy p -> (p => r) -> r
deferred :: Deferrable p :- p
instance GHC.Show.Show Data.Constraint.Deferrable.UnsatisfiedConstraint
instance GHC.Exception.Exception Data.Constraint.Deferrable.UnsatisfiedConstraint
instance (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b) => Data.Constraint.Deferrable.Deferrable (a ~ b)
instance (Data.Constraint.Deferrable.Deferrable a, Data.Constraint.Deferrable.Deferrable b) => Data.Constraint.Deferrable.Deferrable (a, b)
instance (Data.Constraint.Deferrable.Deferrable a, Data.Constraint.Deferrable.Deferrable b, Data.Constraint.Deferrable.Deferrable c) => Data.Constraint.Deferrable.Deferrable (a, b, c)


-- | This module uses a trick to provide quantification over constraints.
module Data.Constraint.Forall

-- | A representation of the quantified constraint <tt>forall a. p a</tt>.

-- | Instantiate a quantified <tt><a>Forall</a> p</tt> constraint at type
--   <tt>a</tt>.
inst :: Forall p :- p a

-- | A representation of the quantified constraint <tt>forall a. p (f
--   a)</tt>.

-- | Instantiate a quantified <tt><a>ForallF</a> p f</tt> constraint at
--   type <tt>a</tt>.
instF :: ForallF p f :- p (f a)
type Forall1 p = Forall p

-- | Instantiate a quantified constraint on kind <tt>* -&gt; *</tt>. This
--   is now redundant since <tt><a>inst</a></tt> became polykinded.
inst1 :: Forall p :- p f

-- | A representation of the quantified constraint <tt>forall f a. p (t f
--   a)</tt>.

-- | Instantiate a quantified <tt><a>ForallT</a> p t</tt> constraint at
--   types <tt>f</tt> and <tt>a</tt>.
instT :: ForallT p t :- p (t f a)
instance forall (k :: BOX) (p :: k -> GHC.Prim.Constraint). p (Data.Constraint.Forall.Skolem p) => Data.Constraint.Forall.Forall_ p
instance forall (k2 :: BOX) (k1 :: BOX) (p :: k2 -> GHC.Prim.Constraint) (f :: k1 -> k2). p (f (Data.Constraint.Forall.SkolemF p f)) => Data.Constraint.Forall.ForallF_ p f
instance forall (k3 :: BOX) (k1 :: BOX) (k2 :: BOX) (p :: k3 -> GHC.Prim.Constraint) (t :: k1 -> k2 -> k3). p (t (Data.Constraint.Forall.SkolemT1 p t) (Data.Constraint.Forall.SkolemT2 p t)) => Data.Constraint.Forall.ForallT_ p t

module Data.Constraint.Lifting
class Lifting p f
lifting :: Lifting p f => p a :- p (f a)
class Lifting2 p f
lifting2 :: Lifting2 p f => p a :- Lifting p (f a)
instance Data.Constraint.Lifting.Lifting GHC.Classes.Eq []
instance Data.Constraint.Lifting.Lifting GHC.Classes.Ord []
instance Data.Constraint.Lifting.Lifting GHC.Show.Show []
instance Data.Constraint.Lifting.Lifting GHC.Read.Read []
instance Data.Constraint.Lifting.Lifting Data.Hashable.Class.Hashable []
instance Data.Constraint.Lifting.Lifting Data.Binary.Class.Binary []
instance Data.Constraint.Lifting.Lifting Control.DeepSeq.NFData []
instance Data.Constraint.Lifting.Lifting GHC.Classes.Eq GHC.Base.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Classes.Ord GHC.Base.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Show.Show GHC.Base.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Read.Read GHC.Base.Maybe
instance Data.Constraint.Lifting.Lifting Data.Hashable.Class.Hashable GHC.Base.Maybe
instance Data.Constraint.Lifting.Lifting Data.Binary.Class.Binary GHC.Base.Maybe
instance Data.Constraint.Lifting.Lifting Control.DeepSeq.NFData GHC.Base.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Base.Monoid GHC.Base.Maybe
instance Data.Constraint.Lifting.Lifting GHC.Classes.Eq GHC.Real.Ratio
instance Data.Constraint.Lifting.Lifting GHC.Classes.Eq Data.Complex.Complex
instance Data.Constraint.Lifting.Lifting GHC.Read.Read Data.Complex.Complex
instance Data.Constraint.Lifting.Lifting GHC.Show.Show Data.Complex.Complex
instance Data.Constraint.Lifting.Lifting GHC.Base.Monoid ((->) a)
instance GHC.Classes.Eq a => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Data.Either.Either a)
instance GHC.Classes.Ord a => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Data.Either.Either a)
instance GHC.Show.Show a => Data.Constraint.Lifting.Lifting GHC.Show.Show (Data.Either.Either a)
instance GHC.Read.Read a => Data.Constraint.Lifting.Lifting GHC.Read.Read (Data.Either.Either a)
instance Data.Hashable.Class.Hashable a => Data.Constraint.Lifting.Lifting Data.Hashable.Class.Hashable (Data.Either.Either a)
instance Data.Binary.Class.Binary a => Data.Constraint.Lifting.Lifting Data.Binary.Class.Binary (Data.Either.Either a)
instance Control.DeepSeq.NFData a => Data.Constraint.Lifting.Lifting Control.DeepSeq.NFData (Data.Either.Either a)
instance GHC.Classes.Eq a => Data.Constraint.Lifting.Lifting GHC.Classes.Eq ((,) a)
instance GHC.Classes.Ord a => Data.Constraint.Lifting.Lifting GHC.Classes.Ord ((,) a)
instance GHC.Show.Show a => Data.Constraint.Lifting.Lifting GHC.Show.Show ((,) a)
instance GHC.Read.Read a => Data.Constraint.Lifting.Lifting GHC.Read.Read ((,) a)
instance Data.Hashable.Class.Hashable a => Data.Constraint.Lifting.Lifting Data.Hashable.Class.Hashable ((,) a)
instance Data.Binary.Class.Binary a => Data.Constraint.Lifting.Lifting Data.Binary.Class.Binary ((,) a)
instance Control.DeepSeq.NFData a => Data.Constraint.Lifting.Lifting Control.DeepSeq.NFData ((,) a)
instance GHC.Base.Monoid a => Data.Constraint.Lifting.Lifting GHC.Base.Monoid ((,) a)
instance GHC.Enum.Bounded a => Data.Constraint.Lifting.Lifting GHC.Enum.Bounded ((,) a)
instance GHC.Arr.Ix a => Data.Constraint.Lifting.Lifting GHC.Arr.Ix ((,) a)
instance GHC.Base.Functor f => Data.Constraint.Lifting.Lifting GHC.Base.Functor (Data.Functor.Compose.Compose f)
instance Data.Foldable.Foldable f => Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Data.Functor.Compose.Compose f)
instance Data.Traversable.Traversable f => Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Data.Functor.Compose.Compose f)
instance GHC.Base.Applicative f => Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Data.Functor.Compose.Compose f)
instance GHC.Base.Alternative f => Data.Constraint.Lifting.Lifting GHC.Base.Alternative (Data.Functor.Compose.Compose f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f) => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Data.Functor.Compose.Compose f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f) => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Data.Functor.Compose.Compose f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f) => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Data.Functor.Compose.Compose f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Read1 f) => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Data.Functor.Compose.Compose f)
instance (GHC.Base.Functor f, Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Data.Functor.Compose.Compose f g)
instance (GHC.Base.Functor f, Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Data.Functor.Compose.Compose f g)
instance GHC.Base.Functor f => Data.Constraint.Lifting.Lifting GHC.Base.Functor (Data.Functor.Product.Product f)
instance Data.Foldable.Foldable f => Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Data.Functor.Product.Product f)
instance Data.Traversable.Traversable f => Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Data.Functor.Product.Product f)
instance GHC.Base.Applicative f => Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Data.Functor.Product.Product f)
instance GHC.Base.Alternative f => Data.Constraint.Lifting.Lifting GHC.Base.Alternative (Data.Functor.Product.Product f)
instance GHC.Base.Monad f => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Data.Functor.Product.Product f)
instance Control.Monad.Fix.MonadFix f => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Data.Functor.Product.Product f)
instance GHC.Base.MonadPlus f => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Data.Functor.Product.Product f)
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Data.Functor.Product.Product f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Data.Functor.Product.Product f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Data.Functor.Product.Product f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Data.Functor.Product.Product f)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Data.Functor.Product.Product f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Data.Functor.Product.Product f g)
instance GHC.Base.Functor f => Data.Constraint.Lifting.Lifting GHC.Base.Functor (Data.Functor.Sum.Sum f)
instance Data.Foldable.Foldable f => Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Data.Functor.Sum.Sum f)
instance Data.Traversable.Traversable f => Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Data.Functor.Sum.Sum f)
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Data.Functor.Sum.Sum f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Data.Functor.Sum.Sum f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Data.Functor.Sum.Sum f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Data.Functor.Sum.Sum f)
instance (Data.Functor.Classes.Eq1 f, Data.Functor.Classes.Eq1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Ord1 f, Data.Functor.Classes.Ord1 g) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Read1 f, Data.Functor.Classes.Read1 g) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Data.Functor.Sum.Sum f g)
instance (Data.Functor.Classes.Show1 f, Data.Functor.Classes.Show1 g) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Data.Functor.Sum.Sum f g)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Reader.ReaderT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Error.ErrorT e)
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Control.Monad.Trans.Error.ErrorT e)
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Control.Monad.Trans.Error.ErrorT e)
instance Control.Monad.Trans.Error.Error e => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Error.ErrorT e)
instance Control.Monad.Trans.Error.Error e => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.Error.ErrorT e)
instance Control.Monad.Trans.Error.Error e => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.Error.ErrorT e)
instance Control.Monad.Trans.Error.Error e => Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Error.ErrorT e)
instance GHC.Show.Show e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Control.Monad.Trans.Error.ErrorT e)
instance GHC.Classes.Eq e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Control.Monad.Trans.Error.ErrorT e)
instance GHC.Classes.Ord e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Control.Monad.Trans.Error.ErrorT e)
instance GHC.Read.Read e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Control.Monad.Trans.Error.ErrorT e)
instance (GHC.Show.Show e, Data.Functor.Classes.Show1 m) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Error.ErrorT e m)
instance (GHC.Read.Read e, Data.Functor.Classes.Read1 m) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Error.ErrorT e m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.Except.ExceptT e)
instance GHC.Base.Monoid e => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Except.ExceptT e)
instance GHC.Show.Show e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Control.Monad.Trans.Except.ExceptT e)
instance GHC.Classes.Eq e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Control.Monad.Trans.Except.ExceptT e)
instance GHC.Classes.Ord e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Control.Monad.Trans.Except.ExceptT e)
instance GHC.Read.Read e => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Control.Monad.Trans.Except.ExceptT e)
instance (GHC.Show.Show e, Data.Functor.Classes.Show1 m) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Classes.Eq e, Data.Functor.Classes.Eq1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Classes.Ord e, Data.Functor.Classes.Ord1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Read.Read e, Data.Functor.Classes.Read1 m) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Alternative (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.Writer.Strict.WriterT w)
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Control.Monad.Trans.Writer.Strict.WriterT w)
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Show.Show w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Classes.Eq w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Classes.Ord w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Read.Read w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Control.Monad.Trans.Writer.Strict.WriterT w)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Alternative (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Show.Show w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Classes.Eq w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Classes.Ord w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance GHC.Read.Read w => Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance (GHC.Show.Show w, Data.Functor.Classes.Show1 m) => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Classes.Eq w, Data.Functor.Classes.Eq1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Classes.Ord w, Data.Functor.Classes.Ord1 m) => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Read.Read w, Data.Functor.Classes.Read1 m) => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor (Control.Monad.Trans.Cont.ContT r)
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative (Control.Monad.Trans.Cont.ContT r)
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad (Control.Monad.Trans.Cont.ContT r)
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Cont.ContT r)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Control.Monad.Fix.MonadFix Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Control.Monad.Trans.Identity.IdentityT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Control.Monad.Trans.Identity.IdentityT
instance Data.Functor.Classes.Show1 m => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Functor.Classes.Read1 m => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Functor.Classes.Ord1 m => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Functor.Classes.Eq1 m => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Control.Monad.Trans.List.ListT
instance Data.Functor.Classes.Show1 m => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Classes.Read1 m => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Classes.Ord1 m => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.List.ListT m)
instance Data.Functor.Classes.Eq1 m => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.List.ListT m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting GHC.Base.Monad Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting GHC.Base.MonadPlus Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Control.Monad.IO.Class.MonadIO Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Control.Monad.Trans.Maybe.MaybeT
instance Data.Functor.Classes.Show1 m => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Read1 m => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Ord1 m => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Functor.Classes.Eq1 m => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Monad.Trans.Maybe.MaybeT m)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Data.Functor.Reverse.Reverse
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Data.Functor.Reverse.Reverse
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting GHC.Show.Show (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting GHC.Read.Read (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Data.Functor.Reverse.Reverse f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Data.Functor.Reverse.Reverse f)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Control.Applicative.Backwards.Backwards
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Control.Applicative.Backwards.Backwards
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Applicative.Backwards.Backwards f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Applicative.Backwards.Backwards f)
instance Data.Constraint.Lifting.Lifting GHC.Base.Functor Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Foldable.Foldable Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Traversable.Traversable Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting GHC.Base.Applicative Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting GHC.Base.Alternative Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Show1 Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Read1 Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Ord1 Control.Applicative.Lift.Lift
instance Data.Constraint.Lifting.Lifting Data.Functor.Classes.Eq1 Control.Applicative.Lift.Lift
instance Data.Functor.Classes.Show1 f => Data.Constraint.Lifting.Lifting GHC.Show.Show (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Read1 f => Data.Constraint.Lifting.Lifting GHC.Read.Read (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Ord1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Ord (Control.Applicative.Lift.Lift f)
instance Data.Functor.Classes.Eq1 f => Data.Constraint.Lifting.Lifting GHC.Classes.Eq (Control.Applicative.Lift.Lift f)
instance Data.Constraint.Lifting.Lifting GHC.Classes.Eq Data.Functor.Identity.Identity
instance Data.Constraint.Lifting.Lifting GHC.Classes.Ord Data.Functor.Identity.Identity
instance Data.Constraint.Lifting.Lifting GHC.Show.Show Data.Functor.Identity.Identity
instance Data.Constraint.Lifting.Lifting GHC.Read.Read Data.Functor.Identity.Identity
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont Control.Monad.Trans.Identity.IdentityT
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Control.Monad.Trans.Error.Error e => Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Error.ErrorT e)
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Except.ExceptT w)
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Reader.ReaderT e)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) Control.Monad.Trans.Identity.IdentityT
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.Reader.ReaderT r)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.RWS.Strict.RWST r w s)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Error.Class.MonadError e) (Control.Monad.Trans.RWS.Lazy.RWST r w s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.RWS.Class.MonadRWS r w s) Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting (Control.Monad.RWS.Class.MonadRWS r w s) Control.Monad.Trans.Identity.IdentityT
instance Control.Monad.Trans.Error.Error e => Data.Constraint.Lifting.Lifting (Control.Monad.RWS.Class.MonadRWS r w s) (Control.Monad.Trans.Error.ErrorT e)
instance Data.Constraint.Lifting.Lifting (Control.Monad.RWS.Class.MonadRWS r w s) (Control.Monad.Trans.Except.ExceptT e)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) Control.Monad.Trans.Identity.IdentityT
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.State.Strict.StateT s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.State.Lazy.StateT s)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.Except.ExceptT e)
instance Control.Monad.Trans.Error.Error e => Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.Error.ErrorT e)
instance Data.Constraint.Lifting.Lifting (Control.Monad.Reader.Class.MonadReader r) (Control.Monad.Trans.Cont.ContT r')
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) Control.Monad.Trans.Maybe.MaybeT
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) Control.Monad.Trans.List.ListT
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) Control.Monad.Trans.Identity.IdentityT
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Writer.Strict.WriterT w)
instance GHC.Base.Monoid w => Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Writer.Lazy.WriterT w)
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Reader.ReaderT r)
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Except.ExceptT e)
instance Control.Monad.Trans.Error.Error e => Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Error.ErrorT e)
instance Data.Constraint.Lifting.Lifting (Control.Monad.State.Class.MonadState s) (Control.Monad.Trans.Cont.ContT r')
instance Data.Constraint.Lifting.Lifting2 GHC.Classes.Eq Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 GHC.Classes.Ord Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 GHC.Show.Show Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 GHC.Read.Read Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 Data.Hashable.Class.Hashable Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 Data.Binary.Class.Binary Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 Control.DeepSeq.NFData Data.Either.Either
instance Data.Constraint.Lifting.Lifting2 GHC.Classes.Eq (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Classes.Ord (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Show.Show (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Read.Read (,)
instance Data.Constraint.Lifting.Lifting2 Data.Hashable.Class.Hashable (,)
instance Data.Constraint.Lifting.Lifting2 Data.Binary.Class.Binary (,)
instance Data.Constraint.Lifting.Lifting2 Control.DeepSeq.NFData (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Monoid (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Enum.Bounded (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Arr.Ix (,)
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Functor Data.Functor.Compose.Compose
instance Data.Constraint.Lifting.Lifting2 Data.Foldable.Foldable Data.Functor.Compose.Compose
instance Data.Constraint.Lifting.Lifting2 Data.Traversable.Traversable Data.Functor.Compose.Compose
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Applicative Data.Functor.Compose.Compose
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Alternative Data.Functor.Compose.Compose
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Functor Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Foldable.Foldable Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Traversable.Traversable Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Applicative Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Alternative Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Monad Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 GHC.Base.MonadPlus Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Control.Monad.Fix.MonadFix Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Show1 Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Eq1 Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Ord1 Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Read1 Data.Functor.Product.Product
instance Data.Constraint.Lifting.Lifting2 GHC.Base.Functor Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Foldable.Foldable Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Traversable.Traversable Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Show1 Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Eq1 Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Ord1 Data.Functor.Sum.Sum
instance Data.Constraint.Lifting.Lifting2 Data.Functor.Classes.Read1 Data.Functor.Sum.Sum


module Data.Constraint.Unsafe

-- | This two-parameter class has instances for types <tt>a</tt> and
--   <tt>b</tt> if the compiler can infer that they have the same
--   representation. This class does not have regular instances; instead
--   they are created on-the-fly during type-checking. Trying to manually
--   declare an instance of <tt>Coercible</tt> is an error.
--   
--   Nevertheless one can pretend that the following three kinds of
--   instances exist. First, as a trivial base-case:
--   
--   <pre>
--   instance a a
--   </pre>
--   
--   Furthermore, for every type constructor there is an instance that
--   allows to coerce under the type constructor. For example, let
--   <tt>D</tt> be a prototypical type constructor (<tt>data</tt> or
--   <tt>newtype</tt>) with three type arguments, which have roles
--   <tt>nominal</tt>, <tt>representational</tt> resp. <tt>phantom</tt>.
--   Then there is an instance of the form
--   
--   <pre>
--   instance Coercible b b' =&gt; Coercible (D a b c) (D a b' c')
--   </pre>
--   
--   Note that the <tt>nominal</tt> type arguments are equal, the
--   <tt>representational</tt> type arguments can differ, but need to have
--   a <tt>Coercible</tt> instance themself, and the <tt>phantom</tt> type
--   arguments can be changed arbitrarily.
--   
--   The third kind of instance exists for every <tt>newtype NT = MkNT
--   T</tt> and comes in two variants, namely
--   
--   <pre>
--   instance Coercible a T =&gt; Coercible a NT
--   </pre>
--   
--   <pre>
--   instance Coercible T b =&gt; Coercible NT b
--   </pre>
--   
--   This instance is only usable if the constructor <tt>MkNT</tt> is in
--   scope.
--   
--   If, as a library author of a type constructor like <tt>Set a</tt>, you
--   want to prevent a user of your module to write <tt>coerce :: Set T
--   -&gt; Set NT</tt>, you need to set the role of <tt>Set</tt>'s type
--   parameter to <tt>nominal</tt>, by writing
--   
--   <pre>
--   type role Set nominal
--   </pre>
--   
--   For more details about this feature, please refer to <a>Safe
--   Coercions</a> by Joachim Breitner, Richard A. Eisenberg, Simon Peyton
--   Jones and Stephanie Weirich.
class Coercible (a :: k) (b :: k)

-- | Coerce a dictionary unsafely from one type to another
unsafeCoerceConstraint :: a :- b

-- | Coerce a dictionary unsafely from one type to a newtype of that type
unsafeDerive :: Coercible n o => (o -> n) -> t o :- t n

-- | Coerce a dictionary unsafely from a newtype of a type to the base type
unsafeUnderive :: Coercible n o => (o -> n) -> t n :- t o

-- | Construct an Applicative instance from a Monad
unsafeApplicative :: Monad m => (Applicative m => m a) -> m a

-- | Construct an Alternative instance from a MonadPlus
unsafeAlternative :: MonadPlus m => (Alternative m => m a) -> m a
