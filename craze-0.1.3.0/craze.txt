-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HTTP Racing Library
--   
--   A micro-library for racing HTTP GET requests
@package craze
@version 0.1.3.0

module Network.Craze.Types

-- | A <a>RacerHandler</a> is simply a function for transforming a response
--   after it is received. The handler is only applied to successful
--   requests before they are checked by the <a>RacerChecker</a>.
--   
--   This is primarily for extracting or parsing a <a>CurlResponse_</a>
--   before doing any further work. The type returned by the handler will
--   be used as the input of the checker and will be the return type of
--   functions like <tt>raceGet</tt>.
type RacerHandler headerTy bodyTy a = CurlResponse_ headerTy bodyTy -> IO a

-- | A function that computes whether or not a result is valid or not.
--   
--   A racer will discard successful responses it get from its clients if
--   they do not pass the checker.
--   
--   This step allows the racer to potentially discard responses that,
--   while technically successful, do not contain the expected result (e.g.
--   APIs that return errors as HTTP 200s, rate limitting messages, or
--   unexpected formats).
type RacerChecker a = a -> Bool

-- | A provider is simply a factory function for <a>ProviderOptions</a>,
--   which are used to configure a client.
type RacerProvider = IO ProviderOptions

-- | Configuration used to set up an individual client in the race.
data ProviderOptions
ProviderOptions :: [CurlOption] -> Maybe Int -> Text -> ProviderOptions

-- | Options to pass down to Curl.
[poOptions] :: ProviderOptions -> [CurlOption]

-- | Number of microseconds to delay the request by.
--   
--   Delays can be used to give other clients a headstart. This is useful
--   in cases were some clients are more costly to use than others (e.g.
--   Bandwidth costs, resource usage, etc).
[poDelay] :: ProviderOptions -> Maybe Int

-- | A tag to identify this type provider.
--   
--   Tags are not required to be unique, but they are generally more
--   helpful if they are.
[poTag] :: ProviderOptions -> Text

-- | The status of running a single client.
data ClientStatus a

-- | A successful response (passed the checker). A race will usually only
--   have one successful response.
Successful :: a -> ClientStatus a

-- | A response that was received but failed to pass the checker.
Failed :: a -> ClientStatus a

-- | An exception thrown while using the client.
Errored :: SomeException -> ClientStatus a

-- | The operation is still pending, was cancelled, or was never started.
Pending :: ClientStatus a

-- | The result of a racing operation. This can be used to collect
--   statistics on which providers win more often, etc.
data RacerResult a
RacerResult :: Maybe a -> Maybe ProviderOptions -> [RacerProvider] -> [(Text, ClientStatus a)] -> RacerResult a
[rrResponse] :: RacerResult a -> Maybe a
[rrWinner] :: RacerResult a -> Maybe ProviderOptions
[rrProviders] :: RacerResult a -> [RacerProvider]
[rrStatuses] :: RacerResult a -> [(Text, ClientStatus a)]

-- | A record describing the rules for racing requests.
data Racer headerTy bodyTy a
Racer :: RacerHandler headerTy bodyTy a -> RacerChecker a -> [RacerProvider] -> Bool -> Bool -> Racer headerTy bodyTy a
[racerHandler] :: Racer headerTy bodyTy a -> RacerHandler headerTy bodyTy a
[racerChecker] :: Racer headerTy bodyTy a -> RacerChecker a

-- | On a <a>Racer</a>, each <tt>RaceProvider</tt> represents a separate
--   client configuration. When performing a race, each provider will be
--   used to spwan a client and perform a request. This allows one to
--   control the number of requests performed and with which
--   <a>CurlOption</a>s.
[racerProviders] :: Racer headerTy bodyTy a -> [RacerProvider]

-- | When set to <a>True</a>, debugging messages will be written to stdout.
[racerDebug] :: Racer headerTy bodyTy a -> Bool

-- | When set to <a>True</a>, the Racer will attempt to return the last
--   response in the event that all responses failed to pass the checker.
--   This can be used for identifying error conditions.
[racerReturnLast] :: Racer headerTy bodyTy a -> Bool
instance GHC.Show.Show a => GHC.Show.Show (Network.Craze.Types.ClientStatus a)
instance GHC.Show.Show Network.Craze.Types.ProviderOptions
instance Data.Default.Class.Default Network.Craze.Types.ProviderOptions
instance Data.Default.Class.Default (Network.Craze.Types.Racer [(GHC.Base.String, GHC.Base.String)] Data.ByteString.Internal.ByteString Data.ByteString.Internal.ByteString)

module Network.Craze.Internal
type ClientMap ht bt a = Map (Async (CurlResponse_ ht bt)) (ClientState a)
data ClientState a
ClientState :: ProviderOptions -> ClientStatus a -> ClientState a
[_csOptions] :: ClientState a -> ProviderOptions
[_csStatus] :: ClientState a -> ClientStatus a
data RaceState ht bt a
RaceState :: ClientMap ht bt a -> RacerChecker a -> RacerHandler ht bt a -> Bool -> Bool -> RaceState ht bt a
[_rsClientMap] :: RaceState ht bt a -> ClientMap ht bt a
[_rsChecker] :: RaceState ht bt a -> RacerChecker a
[_rsHandler] :: RaceState ht bt a -> RacerHandler ht bt a
[_rsDebug] :: RaceState ht bt a -> Bool
[_rsReturnLast] :: RaceState ht bt a -> Bool
csStatus :: Lens (ClientState a_akYl) (ClientState a_algQ) (ClientStatus a_akYl) (ClientStatus a_algQ)
csOptions :: Lens' (ClientState a_akYl) ProviderOptions
rsReturnLast :: Lens' (RaceState ht_akYi bt_akYj a_akYk) Bool
rsHandler :: Lens' (RaceState ht_akYi bt_akYj a_akYk) (RacerHandler ht_akYi bt_akYj a_akYk)
rsDebug :: Lens' (RaceState ht_akYi bt_akYj a_akYk) Bool
rsClientMap :: Lens' (RaceState ht_akYi bt_akYj a_akYk) (ClientMap ht_akYi bt_akYj a_akYk)
rsChecker :: Lens' (RaceState ht_akYi bt_akYj a_akYk) (RacerChecker a_akYk)
extractStatuses :: RaceState ht bt a -> [(Text, ClientStatus a)]
makeRaceState :: (CurlHeader ht, CurlBuffer bt, MonadIO m) => Text -> Racer ht bt a -> m (RaceState ht bt a)
makeClientMap :: (CurlHeader ht, CurlBuffer bt, MonadIO m) => Text -> [RacerProvider] -> m (ClientMap ht bt a)
makeClient :: (CurlHeader ht, CurlBuffer bt, MonadIO m) => Text -> RacerProvider -> m (Async (CurlResponse_ ht bt), ClientState a)
performGet :: (CurlHeader ht, CurlBuffer bt) => Text -> ProviderOptions -> IO (CurlResponse_ ht bt)
cancelAll :: MonadIO m => [Async a] -> m ()
cancelRemaining :: (MonadIO m, MonadState (RaceState ht bt a) m) => m ()
identifier :: Async (CurlResponse_ ht bt) -> ProviderOptions -> Text
onlyPending :: ClientMap ht bt a -> ClientMap ht bt a
isPending :: ClientStatus a -> Bool
markAsSuccessful :: (MonadState (RaceState ht bt a) m) => Async (CurlResponse_ ht bt) -> a -> m ()
markAsFailure :: (MonadState (RaceState ht bt a) m) => Async (CurlResponse_ ht bt) -> a -> m ()
markAsErrored :: (MonadState (RaceState ht bt a) m) => Async (CurlResponse_ ht bt) -> SomeException -> m ()
waitForOne :: (Eq a, MonadIO m, MonadState (RaceState ht bt a) m) => m (Maybe (Async (CurlResponse_ ht bt), a))


-- | Craze is a small module for performing multiple similar HTTP GET
--   requests in parallel. This is performed through the <a>raceGet</a>
--   function, which will perform all the requests and pick the first
--   successful response that passes a certain check, meaning that the
--   parallel requests are essentially racing against each other.
--   
--   <b>What is the usefulness of this?</b>
--   
--   If you are dealing with data source or API that is very unreliable
--   (high latency, random failures) and there are no limitations on
--   performing significantly more requests, then performing multiple
--   requests (through direct connections, proxies, VPNs) may increase the
--   chances of getting a successful response faster and more reliably.
--   
--   However, if using a different data source or transport is a
--   possibility, it is potentially a better option that this approach.
--   
--   <b>Examples:</b>
--   
--   Performing two parallel GET requests against
--   <a>https://chromabits.com</a> and returning the status code of the
--   first successful one:
--   
--   The providers generate two client configurations. The handler "parses"
--   the response (in this case it just gets the status code). Finally, the
--   checker filters out responses that we don't consider valid (anything
--   that is not HTTP 200 in this case).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; :{
--    let racer = (Racer
--                  { racerProviders =
--                      [ simpleTagged [] "Client A"
--                      , simpleTagged [] "Client B"
--                      ]
--                  , racerHandler = return . respStatus
--                  , racerChecker = (200 ==)
--                  , racerDebug = False
--                  , racerReturnLast = False
--                  } :: Racer [(String, String)] ByteString Int)
--    in (raceGet racer "https://chromabits.com" &gt;&gt;= print)
--   :}
--   Just 200
--   </pre>
module Network.Craze

-- | A <a>RacerHandler</a> is simply a function for transforming a response
--   after it is received. The handler is only applied to successful
--   requests before they are checked by the <a>RacerChecker</a>.
--   
--   This is primarily for extracting or parsing a <a>CurlResponse_</a>
--   before doing any further work. The type returned by the handler will
--   be used as the input of the checker and will be the return type of
--   functions like <tt>raceGet</tt>.
type RacerHandler headerTy bodyTy a = CurlResponse_ headerTy bodyTy -> IO a

-- | A function that computes whether or not a result is valid or not.
--   
--   A racer will discard successful responses it get from its clients if
--   they do not pass the checker.
--   
--   This step allows the racer to potentially discard responses that,
--   while technically successful, do not contain the expected result (e.g.
--   APIs that return errors as HTTP 200s, rate limitting messages, or
--   unexpected formats).
type RacerChecker a = a -> Bool

-- | A record describing the rules for racing requests.
data Racer headerTy bodyTy a
Racer :: RacerHandler headerTy bodyTy a -> RacerChecker a -> [RacerProvider] -> Bool -> Bool -> Racer headerTy bodyTy a
[racerHandler] :: Racer headerTy bodyTy a -> RacerHandler headerTy bodyTy a
[racerChecker] :: Racer headerTy bodyTy a -> RacerChecker a

-- | On a <a>Racer</a>, each <tt>RaceProvider</tt> represents a separate
--   client configuration. When performing a race, each provider will be
--   used to spwan a client and perform a request. This allows one to
--   control the number of requests performed and with which
--   <a>CurlOption</a>s.
[racerProviders] :: Racer headerTy bodyTy a -> [RacerProvider]

-- | When set to <a>True</a>, debugging messages will be written to stdout.
[racerDebug] :: Racer headerTy bodyTy a -> Bool

-- | When set to <a>True</a>, the Racer will attempt to return the last
--   response in the event that all responses failed to pass the checker.
--   This can be used for identifying error conditions.
[racerReturnLast] :: Racer headerTy bodyTy a -> Bool

-- | A provider is simply a factory function for <a>ProviderOptions</a>,
--   which are used to configure a client.
type RacerProvider = IO ProviderOptions

-- | Configuration used to set up an individual client in the race.
data ProviderOptions
ProviderOptions :: [CurlOption] -> Maybe Int -> Text -> ProviderOptions

-- | Options to pass down to Curl.
[poOptions] :: ProviderOptions -> [CurlOption]

-- | Number of microseconds to delay the request by.
--   
--   Delays can be used to give other clients a headstart. This is useful
--   in cases were some clients are more costly to use than others (e.g.
--   Bandwidth costs, resource usage, etc).
[poDelay] :: ProviderOptions -> Maybe Int

-- | A tag to identify this type provider.
--   
--   Tags are not required to be unique, but they are generally more
--   helpful if they are.
[poTag] :: ProviderOptions -> Text

-- | The result of a racing operation. This can be used to collect
--   statistics on which providers win more often, etc.
data RacerResult a
RacerResult :: Maybe a -> Maybe ProviderOptions -> [RacerProvider] -> [(Text, ClientStatus a)] -> RacerResult a
[rrResponse] :: RacerResult a -> Maybe a
[rrWinner] :: RacerResult a -> Maybe ProviderOptions
[rrProviders] :: RacerResult a -> [RacerProvider]
[rrStatuses] :: RacerResult a -> [(Text, ClientStatus a)]

-- | The status of running a single client.
data ClientStatus a

-- | A successful response (passed the checker). A race will usually only
--   have one successful response.
Successful :: a -> ClientStatus a

-- | A response that was received but failed to pass the checker.
Failed :: a -> ClientStatus a

-- | An exception thrown while using the client.
Errored :: SomeException -> ClientStatus a

-- | The operation is still pending, was cancelled, or was never started.
Pending :: ClientStatus a

-- | Perform a GET request on the provided URL using all providers in
--   parallel.
--   
--   Rough summary of the algorithm:
--   
--   <ul>
--   <li>Start all requests</li>
--   <li>Wait for a request to finish.<ul><li>If the request is successful,
--   apply the handler on it.<ul><li>If the result of the handler passes
--   the checker, cancel all other requests, and return the
--   result.</li><li>If the check fails, go back to waiting for another
--   request to finish.</li></ul></li><li>If the request fails, go back to
--   waiting for another request to finish.</li></ul></li>
--   </ul>
raceGet :: (Eq a, CurlHeader ht, CurlBuffer bt, MonadIO m) => Racer ht bt a -> URLString -> m (Maybe a)

-- | Same as <tt>raceGet</tt>, but returns a <tt>RacerResult</tt> which
--   contains more information about the race performed.
raceGetResult :: (Eq a, CurlHeader ht, CurlBuffer bt, MonadIO m) => Racer ht bt a -> URLString -> m (RacerResult a)

-- | A simple provider. It does not delay requests.
simple :: Monad m => [CurlOption] -> m ProviderOptions

-- | Like <tt>simple</tt>, but with a tag for identification.
simpleTagged :: Monad m => [CurlOption] -> Text -> m ProviderOptions

-- | A provider which will delay a request by the provided number of
--   microseconds.
delayed :: Monad m => [CurlOption] -> Int -> m ProviderOptions

-- | Like <tt>delayed</tt>, but with a tag for identification.
delayedTagged :: Monad m => [CurlOption] -> Int -> Text -> m ProviderOptions

-- | A <a>Racer</a> with some default values.
--   
--   <b>Note:</b> The handler will extract the response body as a
--   <a>ByteString</a> and ignore everything else, hence the type:
--   
--   <pre>
--   Racer [(String, String)] ByteString ByteString
--   </pre>
--   
--   If this is not the desired behavior, or if the response should be
--   parsed or processed, you should use the <a>Racer</a> constructor
--   directly and provide all fields.

-- | <i>Deprecated: Use Data.Default.Class.def instead</i>
defaultRacer :: Racer [(String, String)] ByteString ByteString

-- | A default set of options for a provider.

-- | <i>Deprecated: Use Data.Default.Class.def instead</i>
defaultProviderOptions :: ProviderOptions
